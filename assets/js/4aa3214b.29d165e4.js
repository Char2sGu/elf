"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[37],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,f=u["".concat(c,".").concat(d)]||u[d]||m[d]||a;return n?o.createElement(f,s(s({ref:t},p),{},{components:n})):o.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},512:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const a={},s="Batching",i={unversionedId:"miscellaneous/batching",id:"miscellaneous/batching",title:"Batching",description:"When using the store's update function, you can pass multiple mutation functions:",source:"@site/docs/miscellaneous/batching.mdx",sourceDirName:"miscellaneous",slug:"/miscellaneous/batching",permalink:"/elf/docs/miscellaneous/batching",draft:!1,editUrl:"https://github.com/ngneat/elf/docusaurus/edit/main/website/docs/miscellaneous/batching.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Hooks",permalink:"/elf/docs/miscellaneous/hooks"},next:{title:"Recipes",permalink:"/elf/docs/recipes"}},c={},l=[{value:"emitOnce",id:"emitonce",level:2},{value:"emitOnceAsync",id:"emitonceasync",level:2}],p={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"batching"},"Batching"),(0,r.kt)("p",null,"When using the store's ",(0,r.kt)("inlineCode",{parentName:"p"},"update")," function, you can pass multiple mutation functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"store.update(\n  setProp('count', 1),\n  addEntities([todo, todo]),\n  deleteEntities(1)\n);\n")),(0,r.kt)("p",null,"In this case, subscribers will only receive ",(0,r.kt)("strong",{parentName:"p"},"one")," emission instead of three."),(0,r.kt)("h2",{id:"emitonce"},"emitOnce"),(0,r.kt)("p",null,"There are cases where you have multiple update functions of the ",(0,r.kt)("strong",{parentName:"p"},"same")," store that you want to batch together. To do so you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=todos.repository.ts",title:"todos.repository.ts"},"export function updateCount() {\n  store.update(\n    setProp('count', 1),\n  );\n}\n\nexport function updateUser() {\n  store.update(\n    setProp('user', null),\n  );\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { emitOnce } from '@elf/store';\nimport { updateCount, updateUser } from './todos.repository';\n\nemitOnce(() => {\n  updateCount();\n  updateUser();\n});\n")),(0,r.kt)("p",null,"In this case, subscribers will only receive ",(0,r.kt)("strong",{parentName:"p"},"one")," emission instead of two."),(0,r.kt)("p",null,"Also, you might face the need to use functions that use ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," inside another ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=table.repository.ts",title:"table.repository.ts"},"export function restoreFilters() {\n  emitOnce(() => {\n    store.update(\n      setProp('filters', null),\n    );\n    resetPagination();\n  });\n}\n\nexport function resetSort() {\n  emitOnce(() => {\n    store.update(\n      setProp('sort', null),\n    );\n    resetPagination();\n  });\n}\n\nexport function resetPagination() {\n  store.update(\n    setProp('pagination', null),\n  );\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { emitOnce } from '@elf/store';\nimport { restoreFilters, resetSort } from './table.repository';\n\nemitOnce(() => {\n  restoreFilters();\n  resetSort();\n});\n")),(0,r.kt)("p",null,"In this case, subscribers will only receive ",(0,r.kt)("strong",{parentName:"p"},"one")," emission instead of two."),(0,r.kt)("h2",{id:"emitonceasync"},"emitOnceAsync"),(0,r.kt)("p",null,"In some cases, you might need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," with async functions or observables. To do so, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=todos.repository.ts",title:"todos.repository.ts"},"export async function updateCount() {\n  const newCount = await fetchCount(); // Fetch count from API\n  store.update(setProp('count', newCount));\n}\n\nexport async function updateUser() {\n  const newUser = await fetchUser(); // Fetch user from API\n  store.update(setProp('user', newUser));\n}\n\nexport function clearCount() {\n  store.update(setProp('user', null));\n}\n\nexport function clearUser() {\n  store.update(setProp('user', null));\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { emitOnceAsync } from '@elf/store';\nimport { updateCount, updateUser } from './todos.repository';\n\nawait emitOnceAsync(async () => {\n  await updateCount();\n  await updateUser();\n});\n")),(0,r.kt)("p",null,"In this case, subscribers will also only receive ",(0,r.kt)("strong",{parentName:"p"},"one")," emission instead of two."),(0,r.kt)("p",null,"You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync")," inside another ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { emitOnce, emitOnceAsync } from '@elf/store';\nimport { updateCount, updateUser } from './todos.repository';\n\nasync function updateCountAndUser() {\n  await emitOnceAsync(async () => {\n    await updateCount();\n    await updateUser();\n  });\n}\n\nawait emitOnceAsync(async () => {\n  emitOnce(() => {\n    clearCount();\n    clearUser();\n  });\n  await updateCountAndUser();\n});\n")),(0,r.kt)("p",null,"You can also provide an observable to ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync"),", in this case, the store will only update when the observable emits its ",(0,r.kt)("strong",{parentName:"p"},"first")," value."),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," will not work as expected because ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnce")," will not wait for the async function to finish."),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"emitOnceAsync")," with caution, the store will not update until the async function finishes or the observable emits its first value.\nIf your async function or observable takes too long to finish, the app might appear unresponsive."))}m.isMDXComponent=!0}}]);