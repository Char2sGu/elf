"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[443],{858:(e,t,a)=>{a.d(t,{S:()=>i});var s=a(7294),n=a(9979),r=a(2949);const o={core:{"@ngneat/elf":"latest"},entities:{"@ngneat/elf-entities":"latest"},requests:{"@ngneat/elf-requests":"latest"},pagination:{"@ngneat/elf-pagination":"latest"},devtools:{"@ngneat/elf-devtools":"latest"},persist:{"@ngneat/elf-persist-state":"latest"},history:{"@ngneat/elf-state-history":"latest"},rxjs:{rxjs:"latest"},immer:{immer:"latest"}};function i(e){let{src:t,packages:a=[]}=e;const i=(0,s.useRef)(),l=(0,s.useRef)(),u=["core","rxjs",...a],{colorMode:p}=(0,r.I)();return(0,s.useEffect)((()=>{const e=u.reduce(((e,t)=>(Object.assign(e,o[t]),e)),{});n.Z.embedProject(i.current,{description:"this is descrption",title:"Elf Core",files:{"index.html":"","index.ts":t},template:"typescript",dependencies:e,settings:{compile:{clearConsole:!0}}},{hideDevTools:!1,devToolsHeight:99,theme:p,height:"500px"}).then((e=>{l.current=e.editor}))}),[]),(0,s.useEffect)((()=>{l.current&&l.current.setTheme(p)}),[p]),s.createElement("section",{style:{height:"500px"}},s.createElement("div",{ref:i}))}},3975:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var s=a(7462),n=(a(7294),a(3905));var r=a(858);const o={},i="State History",l={unversionedId:"features/history/history",id:"features/history/history",title:"State History",description:"The stateHistory function provides a convenient way for undo and redo functionality, saving you the trouble of maintaining a history in the app yourself.",source:"@site/docs/features/history/history.mdx",sourceDirName:"features/history",slug:"/features/history/",permalink:"/elf/docs/features/history/",draft:!1,editUrl:"https://github.com/ngneat/elf/docusaurus/edit/main/website/docs/features/history/history.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Persist State",permalink:"/elf/docs/features/persist-state"},next:{title:"Entities State History",permalink:"/elf/docs/features/history/entities-history"}},u={},p=[{value:"API",id:"api",level:2},{value:"<code>undo</code>",id:"undo",level:3},{value:"<code>redo</code>",id:"redo",level:3},{value:"<code>jumpToPast</code>",id:"jumptopast",level:3},{value:"<code>jumpToFuture</code>",id:"jumptofuture",level:3},{value:"<code>clear</code>",id:"clear",level:3},{value:"<code>pause</code>",id:"pause",level:3},{value:"<code>resume</code>",id:"resume",level:3},{value:"<code>getPast</code>",id:"getpast",level:3},{value:"<code>hasPast</code>",id:"haspast",level:3},{value:"<code>hasPast$</code>",id:"haspast-1",level:3},{value:"<code>getFuture</code>",id:"getfuture",level:3},{value:"<code>hasFuture</code>",id:"hasfuture",level:3},{value:"<code>hasFuture$</code>",id:"hasfuture-1",level:3},{value:"<code>resetFutureOnNewState</code>",id:"resetfutureonnewstate",level:3}],d={toc:p};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,s.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"state-history"},"State History"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"stateHistory")," function provides a convenient way for ",(0,n.kt)("inlineCode",{parentName:"p"},"undo")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"redo")," functionality, saving you the trouble of maintaining a history in the app yourself."),(0,n.kt)("p",null,"First, you need to install the package by using the CLI command ",(0,n.kt)("inlineCode",{parentName:"p"},"elf-cli install")," and selecting the stat-history package, or via npm:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @ngneat/elf-state-history\n")),(0,n.kt)("p",null,"Then, call the ",(0,n.kt)("inlineCode",{parentName:"p"},"stateHistory")," method when you want to start monitoring."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"import { createStore } from '@ngneat/elf';\nimport { stateHistory } from '@ngneat/elf-state-history';\n\nconst propsStore = createStore({ name }, withProps<Props>());\n\nexport const propsStateHistory = stateHistory(propsStore);\n")),(0,n.kt)("p",null,"As the second parameter you can pass a ",(0,n.kt)("inlineCode",{parentName:"p"},"StateHistoryOptions")," object, which can be used to define the store's maximum age and state comparator function."),(0,n.kt)(r.S,{src:"import { createStore, withProps } from '@ngneat/elf';\nimport { stateHistory } from '@ngneat/elf-state-history';\n\nconst todosStore = createStore(\n  { name: 'auth' },\n  withProps<{ user: string }>({\n    user: '',\n  })\n);\n\nexport const todosStateHistory = stateHistory(todosStore);\n\ntodosStore.subscribe(console.log);\n\ntodosStore.update((state) => ({\n  ...state,\n  user: 'Elf',\n}));\n\ntodosStateHistory.undo();\n",packages:["history"],mdxType:"LiveDemo"}),(0,n.kt)("h2",{id:"api"},"API"),(0,n.kt)("h3",{id:"undo"},(0,n.kt)("inlineCode",{parentName:"h3"},"undo")),(0,n.kt)("p",null,"Undo the last change:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.undo();\n")),(0,n.kt)("h3",{id:"redo"},(0,n.kt)("inlineCode",{parentName:"h3"},"redo")),(0,n.kt)("p",null,"redo the last change:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.redo();\n")),(0,n.kt)("h3",{id:"jumptopast"},(0,n.kt)("inlineCode",{parentName:"h3"},"jumpToPast")),(0,n.kt)("p",null,"Jump to the provided index in the past (assuming index is valid):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.jumpToPast(number);\n")),(0,n.kt)("h3",{id:"jumptofuture"},(0,n.kt)("inlineCode",{parentName:"h3"},"jumpToFuture")),(0,n.kt)("p",null,"Jump to the provided index in the future (assuming index is valid):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.jumpToFuture(number);\n")),(0,n.kt)("h3",{id:"clear"},(0,n.kt)("inlineCode",{parentName:"h3"},"clear")),(0,n.kt)("p",null,"Clear the history:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.clear();\n\npropsStateHistory.clear(customUpdateFn);\n")),(0,n.kt)("h3",{id:"pause"},(0,n.kt)("inlineCode",{parentName:"h3"},"pause")),(0,n.kt)("p",null,"Stop monitoring the state changes:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.pause();\n")),(0,n.kt)("h3",{id:"resume"},(0,n.kt)("inlineCode",{parentName:"h3"},"resume")),(0,n.kt)("p",null,"Continue monitoring the state changes:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.resume();\n")),(0,n.kt)("h3",{id:"getpast"},(0,n.kt)("inlineCode",{parentName:"h3"},"getPast")),(0,n.kt)("p",null,"Get the whole past history:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.getPast();\n")),(0,n.kt)("h3",{id:"haspast"},(0,n.kt)("inlineCode",{parentName:"h3"},"hasPast")),(0,n.kt)("p",null,"A boolean flag that returns whether the history is not empty:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.hasPast;\n")),(0,n.kt)("h3",{id:"haspast-1"},(0,n.kt)("inlineCode",{parentName:"h3"},"hasPast$")),(0,n.kt)("p",null,"An observable that returns whether the history is not empty:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.hasPast$;\n")),(0,n.kt)("h3",{id:"getfuture"},(0,n.kt)("inlineCode",{parentName:"h3"},"getFuture")),(0,n.kt)("p",null,"Get the whole future history:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.getFuture();\n")),(0,n.kt)("h3",{id:"hasfuture"},(0,n.kt)("inlineCode",{parentName:"h3"},"hasFuture")),(0,n.kt)("p",null,"A boolean flag that returns whether you're not in the latest step in the history:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.hasFuture;\n")),(0,n.kt)("h3",{id:"hasfuture-1"},(0,n.kt)("inlineCode",{parentName:"h3"},"hasFuture$")),(0,n.kt)("p",null,"An observable that returns whether you're not in the latest step in the history:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"propsStateHistory.hasFuture$;\n")),(0,n.kt)("h3",{id:"resetfutureonnewstate"},(0,n.kt)("inlineCode",{parentName:"h3"},"resetFutureOnNewState")),(0,n.kt)("p",null,"A boolean flag in the ",(0,n.kt)("inlineCode",{parentName:"p"},"StateHistoryOptions")," that controls whether the future redo states should be cleared when a new state is added after the user has undone one or more state changes."),(0,n.kt)("p",null,"If ",(0,n.kt)("inlineCode",{parentName:"p"},"resetFutureOnNewState")," is set to ",(0,n.kt)("inlineCode",{parentName:"p"},"true"),", the future states will be cleared when a new state is added. If it's set to ",(0,n.kt)("inlineCode",{parentName:"p"},"false")," (which is the defalt value), the future states will be preserved."),(0,n.kt)("p",null,"Here is how you can set ",(0,n.kt)("inlineCode",{parentName:"p"},"resetFutureOnNewState")," when calling the ",(0,n.kt)("inlineCode",{parentName:"p"},"stateHistory")," method:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const propsStateHistory = stateHistory(propsStore, {\n  resetFutureOnNewState: false,\n});\n")),(0,n.kt)("p",null,"In this example, the future states will not be cleared when a new state is added, allowing the user to still redo previously undone state changes even after a new state has been added."))}h.isMDXComponent=!0}}]);