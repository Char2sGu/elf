"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[971],{858:(t,e,n)=>{n.d(e,{S:()=>a});var i=n(7294),o=n(9979),r=n(2949);const s={core:{"@ngneat/elf":"latest"},entities:{"@ngneat/elf-entities":"latest"},requests:{"@ngneat/elf-requests":"latest"},pagination:{"@ngneat/elf-pagination":"latest"},devtools:{"@ngneat/elf-devtools":"latest"},persist:{"@ngneat/elf-persist-state":"latest"},history:{"@ngneat/elf-state-history":"latest"},rxjs:{rxjs:"latest"},immer:{immer:"latest"}};function a(t){let{src:e,packages:n=[]}=t;const a=(0,i.useRef)(),l=(0,i.useRef)(),d=["core","rxjs",...n],{colorMode:p}=(0,r.I)();return(0,i.useEffect)((()=>{const t=d.reduce(((t,e)=>(Object.assign(t,s[e]),t)),{});o.Z.embedProject(a.current,{description:"this is descrption",title:"Elf Core",files:{"index.html":"","index.ts":e},template:"typescript",dependencies:t,settings:{compile:{clearConsole:!0}}},{hideDevTools:!1,devToolsHeight:99,theme:p,height:"500px"}).then((t=>{l.current=t.editor}))}),[]),(0,i.useEffect)((()=>{l.current&&l.current.setTheme(p)}),[p]),i.createElement("section",{style:{height:"500px"}},i.createElement("div",{ref:a}))}},4548:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var i=n(7462),o=(n(7294),n(3905));var r=n(858);const s={},a="Using Immer",l={unversionedId:"immer",id:"immer",title:"Using Immer",description:"When working with immutable objects, we often get to what\u2019s called a \u201cspread hell\u201d situation. If you prefer working with immutable objects in a mutable fashion, you can use immer with Elf.",source:"@site/docs/immer.mdx",sourceDirName:".",slug:"/immer",permalink:"/elf/docs/immer",draft:!1,editUrl:"https://github.com/ngneat/elf/docusaurus/edit/main/website/docs/immer.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"DevTools",permalink:"/elf/docs/dev-tools"},next:{title:"CLI",permalink:"/elf/docs/cli"}},d={},p=[],c={toc:p};function m(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,i.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"using-immer"},"Using Immer"),(0,o.kt)("p",null,"When working with immutable objects, we often get to what\u2019s called a \u201cspread hell\u201d situation. If you prefer working with immutable objects in a mutable fashion, you can use immer with Elf."),(0,o.kt)("p",null,"Create a mutation function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="store/mutations.ts"',title:'"store/mutations.ts"'},"import { produce } from 'immer';\n\nexport function write<S>(updater: (state: S) => void): (state: S) => S {\n  return function (state) {\n    return produce(state, (draft) => {\n      updater(draft as S);\n    });\n  };\n}\n")),(0,o.kt)("p",null,"Now you can use it in the store's ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.respository.ts"',title:'"todos.respository.ts"'},"import { withProps, createStore } from '@ngneat/elf';\nimport { withEntities, selectAllEntities, updateEntities } from '@ngneat/elf-entities';\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nexport interface TodosProps {\n  filter: 'ALL' | 'ACTIVE' | 'COMPLETED';\n}\n\nconst store = createStore(\n  { name: 'todos' },\n  withEntities<Todo>(),\n  withProps<TodosProps>({ filter: 'ALL' })\n);\n\nexport const todos$ = store.pipe(selectAllEntities());\n\nexport function updateFilter(filter: TodosProps['filter']) {\n  store.update(\n    // highlight-start\n    write((state) => {\n      state.filter = filter;\n    })\n    // highlight-end\n  );\n}\n\nexport function updateCompleted(id: Todo['id']) {\n  store.update(\n    updateEntities(\n      id,\n      // highlight-next-line\n      write<Todo>((entity) => (entity.completed = !entity.completed))\n    )\n  );\n}\n")),(0,o.kt)(r.S,{src:"import { createStore, withProps } from '@ngneat/elf';\nimport {\n  selectAllEntities,\n  updateEntities,\n  withEntities,\n} from '@ngneat/elf-entities';\nimport { produce } from 'immer';\n\nexport function write<S>(updater: (state: S) => void): (state: S) => S {\n  return function (state) {\n    return produce(state, (draft) => {\n      updater(draft as S);\n    });\n  };\n}\n\ninterface Todo {\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nexport interface TodosProps {\n  filter: 'ALL' | 'ACTIVE' | 'COMPLETED';\n}\n\nconst store = createStore(\n  { name: 'todos' },\n  withEntities<Todo>(),\n  withProps<TodosProps>({ filter: 'ALL' })\n);\n\nexport const todos$ = store.pipe(selectAllEntities());\n\nexport function updateFilter(filter: TodosProps['filter']) {\n  store.update(\n    write((state) => {\n      state.filter = filter;\n    })\n  );\n}\n\nexport function updateCompleted(id: Todo['id']) {\n  store.update(\n    updateEntities(\n      id,\n      write<Todo>((entity) => (entity.completed = !entity.completed))\n    )\n  );\n}\n",packages:["entities","immer"],mdxType:"LiveDemo"}))}m.isMDXComponent=!0}}]);