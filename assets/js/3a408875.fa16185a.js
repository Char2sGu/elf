"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[372],{858:(e,t,s)=>{s.d(t,{S:()=>i});var n=s(7294),o=s(9979),a=s(2949);const r={core:{"@ngneat/elf":"latest"},entities:{"@ngneat/elf-entities":"latest"},requests:{"@ngneat/elf-requests":"latest"},pagination:{"@ngneat/elf-pagination":"latest"},devtools:{"@ngneat/elf-devtools":"latest"},persist:{"@ngneat/elf-persist-state":"latest"},history:{"@ngneat/elf-state-history":"latest"},rxjs:{rxjs:"latest"},immer:{immer:"latest"}};function i(e){let{src:t,packages:s=[]}=e;const i=(0,n.useRef)(),l=(0,n.useRef)(),c=["core","rxjs",...s],{colorMode:u}=(0,a.I)();return(0,n.useEffect)((()=>{const e=c.reduce(((e,t)=>(Object.assign(e,r[t]),e)),{});o.Z.embedProject(i.current,{description:"this is descrption",title:"Elf Core",files:{"index.html":"","index.ts":t},template:"typescript",dependencies:e,settings:{compile:{clearConsole:!0}}},{hideDevTools:!1,devToolsHeight:99,theme:u,height:"500px"}).then((e=>{l.current=e.editor}))}),[]),(0,n.useEffect)((()=>{l.current&&l.current.setTheme(u)}),[u]),n.createElement("section",{style:{height:"500px"}},n.createElement("div",{ref:i}))}},4196:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var n=s(7462),o=(s(7294),s(3905));var a=s(858);const r={},i="Cache",l={unversionedId:"features/requests/requests-cache",id:"features/requests/requests-cache",title:"Cache",description:"Using this feature, you can manage the cache status of API calls in your store. First, you need to install the package",source:"@site/docs/features/requests/requests-cache.mdx",sourceDirName:"features/requests",slug:"/features/requests/requests-cache",permalink:"/elf/docs/features/requests/requests-cache",draft:!1,editUrl:"https://github.com/ngneat/elf/docusaurus/edit/main/website/docs/features/requests/requests-cache.mdx",tags:[],version:"current",frontMatter:{}},c={},u=[{value:"Queries",id:"queries",level:2},{value:"<code>selectRequestCache</code>",id:"selectrequestcache",level:3},{value:"<code>getRequestCache</code>",id:"getrequestcache",level:3},{value:"<code>selectIsRequestCached</code>",id:"selectisrequestcached",level:3},{value:"Mutations",id:"mutations",level:2},{value:"<code>updateRequestCache</code>",id:"updaterequestcache",level:3},{value:"<code>updateRequestsCache</code>",id:"updaterequestscache",level:3},{value:"<code>clearRequestsCache</code>",id:"clearrequestscache",level:3}],d={toc:u};function p(e){let{components:t,...s}=e;return(0,o.kt)("wrapper",(0,n.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"cache"},"Cache"),(0,o.kt)("p",null,"Using this feature, you can manage the cache status of API calls in your store. First, you need to install the package\nby using the CLI command ",(0,o.kt)("inlineCode",{parentName:"p"},"elf-cli install")," and selecting the requests package, or via npm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @ngneat/elf-requests\n")),(0,o.kt)("p",null,"To use this feature, provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"withRequestsCache")," props factory function in the ",(0,o.kt)("inlineCode",{parentName:"p"},"createStore")," call:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.repository.ts"',title:'"todos.repository.ts"'},"import { createStore } from '@ngneat/elf';\nimport { withEntities } from '@ngneat/elf-entities';\nimport { withRequestsCache } from '@ngneat/elf-requests';\n\ninterface Todo {\n  id: number;\n  label: string;\n}\n\nconst todosStore = createStore(\n  { name: 'todos' },\n  withEntities<Todo>(),\n  // You can pass the keys type\n  // highlight-next-line\n  withRequestsCache<'todo'|`todo-${string}`>()\n);\n")),(0,o.kt)("p",null,"Now we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"createRequestsCacheOperator")," function that takes a store and returns a custom operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  withRequestsCache,\n  createRequestsCacheOperator,\n} from '@ngneat/elf-requests';\n\nconst todosStore = createStore(\n  { name: 'todos' },\n  withEntities<Todo>(),\n  withRequestsCache<'todo'|`todo-${string}`>()\n);\n\nexport const skipWhileTodosCached = createRequestsCacheOperator(todosStore);\n")),(0,o.kt)("p",null,"We can use the resulting operator and pass a unique key to identify the request. This enables skipping the API call if the passed key is located in the store cache."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.service.ts"',title:'"todos.service.ts"'},"import { setTodos, skipWhileTodosCached } from './todos.repository';\n\nexport function fetchTodos() {\n  return http.get(todosUrl).pipe(\n    tap(setTodos(todos)),\n    // highlight-next-line\n    skipWhileTodosCached('todos')\n  );\n}\n")),(0,o.kt)("p",null,"Use it in tandem with ",(0,o.kt)("inlineCode",{parentName:"p"},"updateRequestsCache"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.repository.ts"',title:'"todos.repository.ts"'},"import { updateRequestCache } from '@ngneat/elf-requests';\nimport { setEntities } from '@ngneat/elf-entities';\n\nexport function setTodos(todos: Todo[]) {\n  store.update(\n    // highlight-next-line\n    updateRequestCache('todos'),\n    setEntities(todos)\n  );\n}\n")),(0,o.kt)("p",null,"Passing a value as the third parameter ensures the ",(0,o.kt)("inlineCode",{parentName:"p"},"store")," will only skip the API call if the value matches the\none passed. Values can be 'none', 'partial' or 'full':"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.repository.ts"',title:'"todos.repository.ts"'},"import { updateRequestCache } from '@ngneat/elf-requests';\n\nexport function setTodos(todos: Todo[]) {\n  store.update(\n    // highlight-next-line\n    updateRequestCache('todos', { value: 'partial' }),\n    setEntities(todos)\n  );\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.service.ts"',title:'"todos.service.ts"'},"import { setTodos, skipWhileTodosCached } from './todos.repository';\n\nexport function fetchTodos() {\n  return http.get(todosUrl).pipe(\n    tap((todos) => setTodos(todos)),\n    // highlight-next-line\n    skipWhileTodosCached('todos', { value: 'partial' })\n  );\n}\n")),(0,o.kt)("p",null,"In addition to value, you can pass in the same object a ",(0,o.kt)("inlineCode",{parentName:"p"},"returnSource")," which will be returned by the operator if the\nrequest is cached. The default return value is ",(0,o.kt)("inlineCode",{parentName:"p"},"EMPTY")," observable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.service.ts"',title:'"todos.service.ts"'},"import { skipWhileTodosCached, setTodos } from './todos.repository';\n\nexport function fetchTodos() {\n  return http.get(todosUrl).pipe(\n    tap((todos) => setTodos(todos)),\n    // highlight-next-line\n    skipWhileTodosCached('todos', { returnSource: of([]) })\n  );\n}\n")),(0,o.kt)(a.S,{src:"import { createStore } from '@ngneat/elf';\nimport { setEntities, withEntities } from '@ngneat/elf-entities';\nimport {\n  createRequestsCacheOperator,\n  selectRequestCache,\n  updateRequestCache,\n  withRequestsCache,\n} from '@ngneat/elf-requests';\nimport { fromFetch } from 'rxjs/fetch';\nimport { tap } from 'rxjs/operators';\n\ninterface Todo {\n  id: number;\n  label: string;\n}\n\nconst todosStore = createStore(\n  { name: 'todos' },\n  withEntities<Todo>(),\n  withRequestsCache<'todos'>()\n);\n\nconst skipWhileTodosCached = createRequestsCacheOperator(todosStore);\n\nexport function setTodos(todos: Todo[]) {\n  todosStore.update(updateRequestCache('todos'), setEntities(todos));\n}\n\ntodosStore.pipe(selectRequestCache('todos')).subscribe((status) => {\n  console.log(status);\n});\n\nfunction fetchTodos() {\n  return fromFetch<Todo[]>('https://jsonplaceholder.typicode.com/todos', {\n    selector: (response) => response.json(),\n  }).pipe(tap(setTodos), skipWhileTodosCached('todos'));\n}\n\nfetchTodos().subscribe(() => console.log('fetched'));\n\n// Use `setTimeout` to simulate a later call\nsetTimeout(() => {\n  fetchTodos().subscribe(() => console.log('You should not see me'));\n}, 1000);\n",packages:["entities","requests"],mdxType:"LiveDemo"}),(0,o.kt)("br",null),(0,o.kt)("p",null,"You can monitor and change the request cache status for your APIs using the following queries and mutations:"),(0,o.kt)("h2",{id:"queries"},"Queries"),(0,o.kt)("h3",{id:"selectrequestcache"},(0,o.kt)("inlineCode",{parentName:"h3"},"selectRequestCache")),(0,o.kt)("p",null,"Select the cache status of the provided request key:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { selectRequestCache } from '@ngneat/elf-requests';\n\ntodosCacheStatus$ = store.pipe(selectRequestCache('todos'));\n")),(0,o.kt)("h3",{id:"getrequestcache"},(0,o.kt)("inlineCode",{parentName:"h3"},"getRequestCache")),(0,o.kt)("p",null,"Get the cache status of the provided request key:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { getRequestCache } from '@ngneat/elf-requests';\n\ntodosCacheStatus = store.query(getRequestCache('todos'));\n")),(0,o.kt)("h3",{id:"selectisrequestcached"},(0,o.kt)("inlineCode",{parentName:"h3"},"selectIsRequestCached")),(0,o.kt)("p",null,"Select whether the cache status of the provided request key isn't ",(0,o.kt)("inlineCode",{parentName:"p"},"none"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { selectIsRequestCached } from '@ngneat/elf-requests';\n\nconst isCached$ = store.pipe(selectIsRequestCached('todos'));\nconst isPartialCached$ = store.pipe(\n  selectIsRequestCached('todos', { value: 'partial' })\n);\n")),(0,o.kt)("p",null,"Get whether the cache status of the provided request key isn't ",(0,o.kt)("inlineCode",{parentName:"p"},"none"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { isRequestCached } from '@ngneat/elf-requests';\n\nconst isCached = store.query(isRequestCached('todos'));\nconst isPartialCached = store.query(\n  isRequestCached('todos', { value: 'partial' })\n);\n")),(0,o.kt)("h2",{id:"mutations"},"Mutations"),(0,o.kt)("h3",{id:"updaterequestcache"},(0,o.kt)("inlineCode",{parentName:"h3"},"updateRequestCache")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { updateRequestCache } from '@ngneat/elf-requests';\n\nstore.update(updateRequestCache('todos'));\nstore.update(updateRequestCache('todos', { value: 'partial' }));\nstore.update(updateRequestCache('todos', { value: 'none' }));\nstore.update(updateRequestCache('todos', { ttl: 1000 }));\n")),(0,o.kt)("p",null,"If you pass ",(0,o.kt)("inlineCode",{parentName:"p"},"ttl")," (time to live) when updating a cache record, that represents the time (in milliseconds) that ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," will\nhave the value that was set (afterward, it reverts to 'none')."),(0,o.kt)("h3",{id:"updaterequestscache"},(0,o.kt)("inlineCode",{parentName:"h3"},"updateRequestsCache")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { updateRequestsCache } from '@ngneat/elf-requests';\n\nstore.update(\n  updateRequestsCache({\n    keyOne: {\n      value: 'partial',\n    },\n  })\n);\n\nstore.update(updateRequestsCache(['keyOne', 'keyTwo'], { value: 'partial' }));\n")),(0,o.kt)("h3",{id:"clearrequestscache"},(0,o.kt)("inlineCode",{parentName:"h3"},"clearRequestsCache")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { clearRequestsCache } from '@ngneat/elf-requests';\n\nstore.update(clearRequestsCache());\n")))}p.isMDXComponent=!0}}]);