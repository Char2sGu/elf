"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[536],{2600:(e,t,n)=>{n.d(t,{k:()=>i});var r=n(6540),s=n(2908),a=n(5293);const o={core:{"@ngneat/elf":"latest"},entities:{"@ngneat/elf-entities":"latest"},requests:{"@ngneat/elf-requests":"latest"},pagination:{"@ngneat/elf-pagination":"latest"},devtools:{"@ngneat/elf-devtools":"latest"},persist:{"@ngneat/elf-persist-state":"latest"},history:{"@ngneat/elf-state-history":"latest"},rxjs:{rxjs:"latest"},immer:{immer:"latest"}};function i(e){let{src:t,packages:n=[]}=e;const i=(0,r.useRef)(),l=(0,r.useRef)(),u=["core","rxjs",...n],{colorMode:c}=(0,a.G)();return(0,r.useEffect)((()=>{const e=u.reduce(((e,t)=>(Object.assign(e,o[t]),e)),{});s.A.embedProject(i.current,{description:"this is descrption",title:"Elf Core",files:{"index.html":"","index.ts":t},template:"typescript",dependencies:e,settings:{compile:{clearConsole:!0}}},{hideDevTools:!1,devToolsHeight:99,theme:c,height:"500px"}).then((e=>{l.current=e.editor}))}),[]),(0,r.useEffect)((()=>{l.current&&l.current.setTheme(c)}),[c]),r.createElement("section",{style:{height:"500px"}},r.createElement("div",{ref:i}))}},3826:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>u,toc:()=>p});var r=n(8168),s=(n(6540),n(5680));const a="import { createStore, select, withProps } from '@ngneat/elf';\n\ninterface AuthProps {\n  user: { id: string } | null;\n}\n\nconst authStore = createStore(\n  { name: 'auth' },\n  withProps<AuthProps>({ user: null })\n);\n\nauthStore.subscribe((state) => {\n  console.log(state);\n});\n\nconst user$ = authStore.pipe(select((state) => state.user));\n\nauthStore.update((state) => ({\n  ...state,\n  user: { id: 'foo' },\n}));\n";var o=n(2600);const i={},l="The Store",u={unversionedId:"store",id:"store",title:"The Store",description:"The createStore function is used to initialize a store with a state.",source:"@site/docs/store.mdx",sourceDirName:".",slug:"/store",permalink:"/elf/docs/store",draft:!1,editUrl:"https://github.com/ngneat/elf/docusaurus/edit/main/website/docs/store.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Installation",permalink:"/elf/docs/installation"},next:{title:"The Repository Pattern",permalink:"/elf/docs/repository"}},c={},p=[{value:"Querying the Store",id:"querying-the-store",level:2},{value:"The <code>select</code> operator",id:"the-select-operator",level:3},{value:"Updating the Store",id:"updating-the-store",level:2},{value:"Updating a root property",id:"updating-a-root-property",level:3}],d={toc:p},h="wrapper";function g(e){let{components:t,...n}=e;return(0,s.yg)(h,(0,r.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"the-store"},"The Store"),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"createStore")," function is used to initialize a store with a state.\nThe first argument is a configuration object where a name of the store is specified.\nAfter the first argument any number of features can be specified which describe the nature of the store."),(0,s.yg)("p",null,"An example of a simple store:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import { createStore, withProps } from '@ngneat/elf';\n\ninterface AuthProps {\n  user: { id: string } | null;\n}\n\nconst authStore = createStore(\n  { name: 'auth' },\n  withProps<AuthProps>({ user: null })\n);\n")),(0,s.yg)("p",null,"An example of a store that contains multiple state features:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const store = createStore(\n  { name: 'todo' },\n  withEntities<Todo>(),\n  withUIEntities<UIEntity>(),\n  withProps<{ foo: string }>({ foo: '' })\n);\n")),(0,s.yg)("p",null,"The features can be either one or more of the available features in Elf, or additional features you can create or add from other sources."),(0,s.yg)("h2",{id:"querying-the-store"},"Querying the Store"),(0,s.yg)("p",null,"A store is a ",(0,s.yg)("inlineCode",{parentName:"p"},"BehaviorSubject"),". Therefore, we can subscribe to it to get its initial value and its subsequent values:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"authStore.subscribe((state) => {\n  console.log(state);\n});\n")),(0,s.yg)("h3",{id:"the-select-operator"},"The ",(0,s.yg)("inlineCode",{parentName:"h3"},"select")," operator"),(0,s.yg)("p",null,"Select a slice from the store:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import { select } from '@ngneat/elf';\n\nconst user$ = authStore.pipe(select((state) => state.user));\n")),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"select()")," operator returns an observable that calls ",(0,s.yg)("inlineCode",{parentName:"p"},"distinctUntilChanged()")," internally, meaning it will only fire when the state changes, i.e., when there is a new reference to the selected state."),(0,s.yg)("p",null,"We can also query its value ",(0,s.yg)("strong",{parentName:"p"},"once")," without the need to subscribe:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const state = authstore.getValue();\n")),(0,s.yg)("h2",{id:"updating-the-store"},"Updating the Store"),(0,s.yg)("p",null,"To update the store, we can use the ",(0,s.yg)("inlineCode",{parentName:"p"},"update")," method which receives a callback function, which gets the current ",(0,s.yg)("inlineCode",{parentName:"p"},"state"),", and returns a new ",(0,s.yg)("strong",{parentName:"p"},"immutable")," ",(0,s.yg)("inlineCode",{parentName:"p"},"state"),", which will be the new value of the store:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"authStore.update((state) => ({\n  ...state,\n  user: { id: 'foo' },\n}));\n")),(0,s.yg)("h3",{id:"updating-a-root-property"},"Updating a root property"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import { setProp, setProps } from '@ngneat/elf';\n\nstore.update(setProp('foo', 'bar'));\nstore.update(setProp('count', (count) => count + 1));\n\nstore.update(\n  setProps({\n    count: 1,\n    child: 2,\n  })\n);\n\nstore.update(\n  setProps((state) => ({\n    count: 1,\n    nested: {\n      ...state.nested,\n      bar: 'baz',\n    },\n  }))\n);\n")),(0,s.yg)(o.k,{src:a,mdxType:"LiveDemo"}))}g.isMDXComponent=!0}}]);